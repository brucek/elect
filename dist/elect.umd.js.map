{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 97b08c113d366e7ee96f","webpack:///./elect.js","webpack:///./Election.js","webpack:///./votingSystems.js","webpack:///./votingStrategies.js","webpack:///./ballots.js","webpack:///./utils.js","webpack:///./aggregateFns.js","webpack:///./~/proto/proto.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wC;;;;;;;;;;ACtCA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,kDAAiD;AACjD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA,qBAAoB;AACpB,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA,yDAAwD;AACxD,UAAS;;AAET;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;;;AAGA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;;;;;;;;;AC3KA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAoB,iBAAiB;AACrC;AACA;AACA,qBAAoB,qBAAqB;AACzC;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,UAAS;;AAET;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,cAAa;AACb,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAoB,0BAA0B;AAC9C;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA;AACA,EAAC;;;;;;;;;;AClID;;;AAGA;AACA;AACA,iBAAgB,qBAAqB;AACrC;AACA;;AAEA;AACA;AACA,MAAK;;AAEL;AACA,iBAAgB;AAChB,MAAK;AACL;AACA,MAAK;;AAEL;AACA,iBAAgB;AAChB,MAAK;AACL;;;AAGA;AACA;AACA;AACA,iEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAwB;;AAExB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,gCAA+B;AAC/B;AACA;AACA,+BAA8B,uBAAuB;AACrD;;AAEA;AACA,wCAAuC;AACvC;AACA;AACA;AACA;AACA;AACA;AACA,0BAAyB;AACzB;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA,+BAA8B,8BAA8B;AAC5D;AACA,UAAS;AACT;AACA;AACA,+BAA8B,uBAAuB;AACrD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAwB;AACxB,cAAa;AACb,yBAAwB;AACxB;AACA,UAAS;AACT;AACA;AACA,2CAA0C;AAC1C;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA,kBAAiB;;AAEjB,kDAAiD;AACjD;AACA,gCAA+B;AAC/B;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA,kBAAiB;;AAEjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB,6DAA6D;AAClF;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,gCAA+B,2CAA2C,SAAS;AACnF;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;;AAET;AACA,4CAA2C,0CAA0C;AACrF;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;AACA,cAAa;;AAEb;AACA;AACA;AACA,cAAa;AACb;;AAEA;AACA;AACA,wDAAuD,SAAS;AAChE;AACA,yBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA,gCAA+B,yEAAyE;AACxG;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iCAAgC;AAChC,UAAS;;AAET;AACA;;AAEA,0DAAyD;AACzD;AACA;AACA,sCAAqC,8CAA8C;AACnF;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,wEAAuE;AACvE;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA,sBAAqB;;AAErB;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,yDAAwD;AACxD;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA,4BAA2B,gCAAgC;AAC3D;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB,cAAc;AACtC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB,cAAa;AACb;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB,cAAa;AACb,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,yBAAwB,qBAAqB;AAC7C;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;;AAEb;AACA,yBAAwB;AACxB,cAAa;;AAEb;AACA;AACA,cAAa;;AAEb;AACA,sBAAqB,wDAAwD;AAC7E,UAAS;AACT;AACA;AACA,yBAAwB,qBAAqB;AAC7C;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB,cAAa;;AAEb;AACA,yBAAwB;AACxB,cAAa;;AAEb;AACA;AACA,cAAa;;AAEb;AACA,yBAAwB,KAAK;AAC7B;AACA;AACA,+BAA8B,uCAAuC;AACrE;AACA;;AAEA;AACA;AACA,cAAa;;AAEb;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA,2BAA0B,2CAA2C;AACrE,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;ACpfA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,wCAAuC;AACvC;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA,iBAAgB;AAChB,MAAK;AACL;AACA,MAAK;;AAEL;AACA;AACA,MAAK;AACL;;;AAGA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,E;;;;;;;;;AC1CA,2BAA0B;;AAE1B;AACA,YAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,E;;;;;;;;;;;AChBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT,MAAK;;AAEL;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA,E;;;;;;;;;;ACnDA;;AAEA;AACA;AACA;AACA,yDAAwD,gCAAgC;AACxF,UAAS;AACT;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA,E;;;;;;;;;ACfA;AACA;;AAEA;;AAEA,mGAAkG,iBAAiB;AACnH;AACA;;AAEA;AACA,uBAAsB;AACtB;;AAEA,MAAK,OAAO;AACZ;AACA;AACA;;AAEA;AACA,yBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,wDAAuD;AACvD;AACA,eAAc;AACd;AACA,MAAK;AACL;AACA;AACA,wDAAuD;AACvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAc;AACd;AACA;;AAEA,gDAA+C;;AAE/C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,wCAAuC;AACvC;;AAEA;AACA;;AAEA,2BAA0B;;AAE1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oEAAmE;AACnE;AACA;AACA,kBAAiB;AACjB;AACA,cAAa;AACb,UAAS;AACT;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,E","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"elect\"] = factory();\n\telse\n\t\troot[\"elect\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 97b08c113d366e7ee96f\n **/","var Election = exports.Election = require(\"./Election\")\r\n\r\nvar systems = exports.systems = require('./votingSystems')\r\nvar strat = exports.strategies = require('./votingStrategies')\r\nvar ballots = exports.ballots = require('./ballots')\r\n\r\n\r\n// For each system:\r\n// algorithm\r\n    // takes in an array of votes where each vote is the output of a given `strategy` for the system\r\n    // returns an object where each key is a winner, and each value is an object with the properties:\r\n        // weight - the winner's vote weight\r\n        // preferences - the winner's voting preferences for each societal option\r\n// each strategy:\r\n    // returns a \"vote\", a set of data used by votingSystem to determine winners\r\nexports.testSystems = {\r\n    Random: {\r\n        winners: [1,3],\r\n        strategies: strat.noop,\r\n        systems: systems.random\r\n    },\r\n    'Random Voters\\' Choice': {\r\n        winners: [1,3],\r\n        strategies: strat.ranked,\r\n        ballots: ballots.ranked,\r\n        systems: systems.randomVotersChoice\r\n    },\r\n    Plurality: {\r\n        winners: [1,3],\r\n        strategies: strat.ranked,\r\n        ballots: ballots.ranked,\r\n        systems: systems.plurality\r\n    },\r\n    Range: {\r\n        winners: [1,3],\r\n        strategies: strat.scored,\r\n        systems: systems.scored,\r\n        ballots: ballots.scored\r\n    },\r\n    'Single-Transferable Vote': {\r\n        winners: [1,3],\r\n        strategies: strat.ranked,\r\n        ballots: ballots.ranked,\r\n        systems: systems.singleTransferableVote\r\n    },\r\n    'Proportional Ranked, 15-Percent Threshold': {\r\n        winners: [3],//[1,3],\r\n        strategies: strat.ranked,\r\n        ballots: ballots.ranked,\r\n        systems: systems.singleTransferableVote\r\n    },\r\n    'Proportional Ranged': {\r\n        winners: [3, Infinity],//[1,3, Infinity],\r\n        strategies: strat.scored,\r\n        ballots: ballots.scored,\r\n        systems: {\r\n            'split-weight, 0% threshold': systems.directRepresentativeRanged['split-weight, 0% threshold'],\r\n            'highest-weight, 20% threshold': systems.directRepresentativeRanged['highest-weight, 20% threshold'],\r\n            'split-weight, minority-max, 20% threshold': systems.directRepresentativeRanged['split-weight, minority-max, 20% threshold'],\r\n            'split-weight, <b>reweighted</b>': systems.directRepresentativeRanged['split-weight, <b>reweighted</b>'],\r\n            'equal-weight, <b>reweighted</b>': systems.directRepresentativeRanged['split-weight, <b>reweighted</b>'],\r\n        }\r\n    },\r\n}\r\n\r\nexports.test = function(resultsDiv, options, votingSystems) {\r\n    if(votingSystems === undefined) throw new Error(\"No voting systems to test\")\r\n\r\n    var numberOfSocietalOptions = options.issues,\r\n        numberOfCandidates = options.candidates,\r\n        numberOfVoters = options.voters,\r\n        iterations = options.iterations\r\n\r\n    var knobsOutput = '<div>Societal Options: '+numberOfSocietalOptions+'</div>'+\r\n                      '<div>Candidates: '+numberOfCandidates+'</div>'+\r\n                      '<div>Voters: '+numberOfVoters+'</div>'+\r\n                      '<div>Iterations: '+iterations+'</div>'+\r\n                      '<br>'\r\n\r\n    var n=1, totalRegretFractionSumPerSystem = {}, totalWinnersPerSystem = {}\r\n    function iteration(complete) {\r\n        var election = Election(numberOfVoters, numberOfCandidates, numberOfSocietalOptions)\r\n\r\n        for(var systemName in votingSystems) {\r\n            var votingSet = votingSystems[systemName]\r\n\r\n            var curBallots = votingSet.ballots\r\n            if(curBallots === undefined) {\r\n                curBallots = ballots.noop\r\n            }\r\n\r\n            for(var strategyName in votingSet.strategies) {\r\n                var rawStrategy = votingSet.strategies[strategyName]\r\n                for(var ballotName in curBallots) {\r\n                    var ballot = curBallots[ballotName]\r\n                    var ballotStrategyName = strategyName+' '+ballotName\r\n                    var strategy = function() {\r\n                        return ballot(rawStrategy.apply(this,arguments))\r\n                    }\r\n\r\n                    for(var algorithmName in votingSet.systems) {\r\n                        votingSet.winners.forEach(function(maxWinners) {\r\n                            var winners = election.elect(votingSet.systems[algorithmName], strategy, election.voters, election.candidates, maxWinners)\r\n                            var regretFraction = election.regretFraction(election.voters, winners)\r\n\r\n                            var systemStrategyName = getVotingTypeName(systemName, ballotStrategyName, algorithmName, maxWinners)\r\n                            if(totalRegretFractionSumPerSystem[systemStrategyName] === undefined) {\r\n                                totalRegretFractionSumPerSystem[systemStrategyName] = 0\r\n                                totalWinnersPerSystem[systemStrategyName] = 0\r\n                            }\r\n\r\n                            totalRegretFractionSumPerSystem[systemStrategyName] += regretFraction\r\n                            totalWinnersPerSystem[systemStrategyName] += winners.length\r\n                        })\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        resultsDiv.innerHTML = resultsHtml(n/iterations, true)\r\n        setTimeout(function() {\r\n            if(n<iterations) {\r\n                iteration(complete)\r\n                n++\r\n            } else {\r\n                complete()\r\n            }\r\n        })\r\n    }\r\n\r\n    var resultsHtml = function(completionFraction, sort) {\r\n        var content = knobsOutput+'Completion: '+Number(100*completionFraction).toPrecision(3)+'%<br>'+\r\n                      '<div><b>Voter Satisfaction Averages (inverse of Bayesian Regret):</b></div>'+\r\n                      '<table>'\r\n\r\n        Object.keys(totalRegretFractionSumPerSystem).map(function(name) {\r\n            return {name:name, totalRegret:totalRegretFractionSumPerSystem[name]}\r\n        }).sort(function(a,b) {\r\n            if(sort) {\r\n                return a.totalRegret - b.totalRegret\r\n            } else {\r\n                return 0\r\n            }\r\n        }).forEach(function(votingType) {\r\n            var systemStrategyName = votingType.name\r\n            var totalRegret = votingType.totalRegret\r\n\r\n            var averageRegretFraction = totalRegret/n\r\n            var avgWinners = (totalWinnersPerSystem[systemStrategyName]/n).toPrecision(2)\r\n\r\n            var displayAverage = Number(100*(1-averageRegretFraction)).toPrecision(2)\r\n            content += '<tr><td style=\"text-align:right;\">'+systemStrategyName+\"</td><td><b>\"+displayAverage+'%</b> with avg of '+avgWinners+' winners</td></tr>'\r\n        })\r\n\r\n        content+= '</table>'\r\n        return content\r\n    }\r\n\r\n    iteration(function() {\r\n        resultsDiv.innerHTML = resultsHtml(1, true)\r\n    })\r\n}\r\n\r\n\r\n// The name of an election run with a particular system and strategy\r\nfunction getVotingTypeName(systemName,strategyName, algorithmName, maxWinners) {\r\n    if(strategyName === 'noname') {\r\n        return systemName\r\n    } else {\r\n        return '<span style=\"color:rgb(0,50,150)\">'+systemName+'</span> '+algorithmName+' '+strategyName+' max '+maxWinners+' winners'\r\n    }\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./elect.js\n ** module id = 0\n ** module chunks = 0\n **/","var proto = require(\"proto\")\r\n\r\nvar utils = require('./utils')\r\nvar aggregateFns = require('./aggregateFns')\r\nvar random = utils.random\r\n\r\nvar Election = module.exports = proto(function() {\r\n    this.init = function(numberOfVoters, numberOfCandidates, numberOfSocietalOptions) {\r\n\r\n        var voters = [], candidates = []\r\n        for(var j=0;j<numberOfVoters;j++) {\r\n            voters.push(generatePerson(numberOfSocietalOptions))\r\n        }\r\n        for(var j=0;j<numberOfCandidates;j++) {\r\n            candidates.push(generatePerson(numberOfSocietalOptions))\r\n        }\r\n\r\n        var netUtilities = findNetUtilities(voters)\r\n        var optimalOutcomes = netUtilities.map(function(optionUtility) {\r\n            return optionUtility > 0\r\n        })\r\n        var leastOptimalOutcomes = optimalOutcomes.map(function(outcome) {\r\n            return !outcome\r\n        })\r\n\r\n        this.maxUtility = totalOutcomeUtility(voters, optimalOutcomes)\r\n        this.minUtility = totalOutcomeUtility(voters, leastOptimalOutcomes)\r\n        this.maxRegret = this.maxUtility - this.minUtility\r\n        this.voters = voters\r\n        this.candidates = candidates\r\n\r\n        this.aggregates = {}\r\n        for(var k in aggregateFns) {\r\n            this.addAggregateFn(k, aggregateFns[k])\r\n        }\r\n    }\r\n\r\n    // returns an array of winning candidates represented by objects that have the properties:\r\n        // weight - That winner's voting weight in the legislature\r\n        // utilities - That winner's option utilities (in the same form as returned by generatePerson)\r\n    // algorithm(votes, candidates) - A function that should return the winning candidates in the same form as this.elect returns\r\n    // strategy(voter, candidates) - A function that should return the given voter's vote in whatever form that algorithm requires\r\n    this.elect = function(algorithm, strategy, voters, candidates, maxWinners) {\r\n        var votes = voters.map(function(voter, index) {\r\n            var voterAggregates = {}\r\n            for(var k in this.aggregates) {\r\n                voterAggregates[k] = this.aggregates[k][index]\r\n            }\r\n\r\n            return strategy(voter, voterAggregates)\r\n        }.bind(this))\r\n\r\n        var results = algorithm(votes, candidates, maxWinners)\r\n\r\n        results.forEach(function(winner) {\r\n            winner.preferences = candidates[winner.index]\r\n            if(winner.weight < 0) throw new Error(\"Winner weight can't be less than 0\")\r\n        })\r\n\r\n        return results\r\n    }\r\n\r\n    this.addAggregateFn = function(name,fn) {\r\n        var that = this\r\n        if(name in this.aggregates) throw new Error(\"Aggregate function '\"+name+\"' already exists\")\r\n\r\n        var values\r\n        Object.defineProperty(this.aggregates, name, {\r\n            get: function() {\r\n                if(values === undefined) {\r\n                    values = fn.call(this, that.voters,that.candidates) // memoize\r\n                }\r\n                return values\r\n            },\r\n            enumerable:true\r\n        })\r\n    }\r\n\r\n    // returns a number from 0 to 1 indicating what percentage of the maximum possible voter regret the deciders cause\r\n    this.regretFraction = function(people, deciders) {\r\n        var outcomes = utils.findSocietalOptionsOutcomes(deciders)\r\n        var totalUtility = totalOutcomeUtility(people, outcomes)\r\n        var regret = this.maxUtility - totalUtility\r\n\r\n        return regret/this.maxRegret\r\n    }\r\n\r\n    // returns the total utility change for the given people if the given outcomes happened\r\n    function totalOutcomeUtility(people, outcomes) {\r\n        var utility = 0\r\n        people.forEach(function(person) {\r\n            utility += utils.voterOutcomeUtility(person, outcomes)\r\n        })\r\n\r\n        return utility\r\n    }\r\n\r\n    // returns an array where the index indicates a societal option and the value indicates\r\n    // the net utility for that option for the people passed in\r\n    function findNetUtilities(people) {\r\n        var netUtility = []\r\n        people.forEach(function(person) {\r\n            person.forEach(function(optionUtility, index) {\r\n                if(netUtility[index] === undefined) {\r\n                    netUtility[index] = 0\r\n                }\r\n\r\n                netUtility[index] += optionUtility\r\n            })\r\n        })\r\n\r\n        return netUtility\r\n    }\r\n\r\n    // Returns an array where each element is a number from -1 to 1 indicating the utility that person would get\r\n    // from a given societal option (identified by the index)\r\n    function generatePerson(numberOfSocietalOptions, optionPopularityModifiers) {\r\n        var voter = []\r\n        for(var n=0;n<numberOfSocietalOptions;n++) {\r\n            if(optionPopularityModifiers) {\r\n                modifier = optionPopularityModifiers[n]\r\n            } else {\r\n                modifier = 1\r\n            }\r\n\r\n            voter[n] = 2*random()*modifier-1\r\n        }\r\n\r\n        return voter\r\n    }\r\n})\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./Election.js\n ** module id = 1\n ** module chunks = 0\n **/","var random = require(\"./utils\").random\r\n\r\n\r\nfunction pluralityAlg(votes, candidates, maxWinners) {\r\n    var results = []\r\n    for(var n=0; n<candidates.length;n++) {\r\n        results[n] = 0\r\n    }\r\n\r\n    votes.forEach(function(vote) {\r\n        results[vote[0]]++\r\n    })\r\n\r\n    var sortedTransformedResults = results.map(function(value,index){\r\n        return {candidate:index,votes:value}\r\n    }).sort(function(a,b) {\r\n        return b.votes - a.votes // reverse sort\r\n    })\r\n\r\n    return sortedTransformedResults.slice(0,maxWinners).map(function(winner) {\r\n        return {index: winner.candidate, weight:1}\r\n    })\r\n}\r\n\r\n\r\n// countType can either be \"normal\" or \"maxMinority\"\r\n    // normal is where the winners are the x candidates with the greatest total score\r\n    // maxMinority is where each successive winner is chosen from only the votes of those who haven't chosen a winner as their top choice\r\n    // reweighted is for a reweighted range vote described here; http://www.rangevoting.org/RRV.html\r\n// winnerWeightType can either be \"highest\" or \"split\"\r\n    // \"highest\" means winner vote weight will be the sum of the number of voters who gave that winner the highest score\r\n    // \"split\" means winner vote weight is the sum of all votes\r\n    // \"equal\" means each winner gets an equal vote weight\r\n// minThreshold is a number from 0 to 1 representing the ratio of average score to the average score of the highest scoring candidate\r\n    // note that the votes are shifted so that they're a range from 0 to 2 for the purposes of calculating this\r\nfunction directRepresentationRange(countType, winnerWeightType, minThreshold) {\r\n    return function(votes, candidates, maxWinners) {\r\n\r\n        var winners = {}, disqualified = {}\r\n\r\n        var countedVotes = countVotes(candidates, votes, winners, disqualified)\r\n        var nextWinner = findNextWinner(countedVotes)\r\n        var highestAvgScore = getAvgScore(countedVotes[nextWinner])\r\n\r\n        countedVotes.forEach(function(info, candidate) {\r\n            var avgScore = getAvgScore(info)\r\n            if(avgScore < highestAvgScore*minThreshold) {\r\n                disqualified[candidate] = true\r\n            }\r\n        })\r\n\r\n        winners[nextWinner] = true\r\n\r\n        while(Object.keys(winners).length < maxWinners && Object.keys(winners).length+Object.keys(disqualified).length < candidates.length) {\r\n            var nextWinnerCountedVotes = countVotes(candidates, votes, winners, disqualified, countType)\r\n\r\n            var nextWinner = findNextWinner(nextWinnerCountedVotes)\r\n            winners[nextWinner] = true\r\n        }\r\n\r\n        if(winnerWeightType === 'highest') {\r\n            var results = []\r\n            var resultsMap = {} //maps a winner to a result index\r\n            for(var winner in winners) {\r\n                resultsMap[winner] = results.length\r\n                results.push({index:winner, weight:0})\r\n            }\r\n\r\n            votes.forEach(function(vote) {\r\n                var highestWinners = {}, highestWinnerScore = -Infinity\r\n                vote.forEach(function(score, candidateIndex) {\r\n                    if(candidateIndex in winners) {\r\n                        if(score > highestWinnerScore) {\r\n                            highestWinners = {}\r\n                            highestWinners[candidateIndex] = true\r\n                            highestWinnerScore = score\r\n                        } else if(score === highestWinnerScore) {\r\n                            highestWinners[candidateIndex] = true\r\n                        }\r\n                    }\r\n                })\r\n\r\n                var numberOfHighestWinners = Object.keys(highestWinners).length\r\n                for(var winner in highestWinners) {\r\n                    results[resultsMap[winner]].weight += 1/numberOfHighestWinners\r\n                }\r\n            })\r\n        } else if(winnerWeightType === 'split') {\r\n            var results = []\r\n            for(var winner in winners) {\r\n                var avgScore = countedVotes[winner].totalScore/countedVotes[winner].totalNumber\r\n                results.push({index:winner, weight:avgScore})\r\n            }\r\n        } else if(winnerWeightType === 'equal') {\r\n            var results = []\r\n            for(var winner in winners) {\r\n                results.push({index:winner, weight:1})\r\n            }\r\n        }\r\n\r\n        return results\r\n    }\r\n\r\n    function getAvgScore(candidateInfo) {\r\n        return candidateInfo.totalScore/candidateInfo.totalNumber\r\n    }\r\n\r\n    function findNextWinner(countedVotes) {\r\n        var nextWinner, curWinnerScore = -Infinity\r\n        countedVotes.forEach(function(info, candidate) {\r\n            if(info.totalScore > curWinnerScore) {\r\n                nextWinner = candidate\r\n                curWinnerScore = info.totalScore\r\n            }\r\n        })\r\n\r\n        return nextWinner\r\n    }\r\n\r\n    function countVotes(candidates, votes, winners, disqualified, countType) {\r\n        if(winners === undefined) winners = {}\r\n        var countedVotes = candidates.map(function(p,c){\r\n            if(!(c in winners) && !(c in disqualified)) {\r\n                return {totalScore:0, totalNumber:0}\r\n            } else {\r\n                return {totalScore:-Infinity, totalNumber:0}\r\n            }\r\n        })\r\n        votes.forEach(function(vote) {\r\n            if(countType === 'maxMinority') {\r\n                var highestCandidates = {}, highestScore = -Infinity\r\n                vote.forEach(function(score, candidateIndex) {\r\n                    if(score > highestScore) {\r\n                        highestCandidates = {}\r\n                        highestCandidates[candidateIndex] = true\r\n                        highestScore = score\r\n                    } else if(score === highestScore) {\r\n                        highestCandidates[candidateIndex] = true\r\n                    }\r\n                })\r\n\r\n                for(var c in highestCandidates) {  // only count votes for people who's highest choice isn't a winner\r\n                    if(c in winners) {\r\n                        return; // continue\r\n                    }\r\n                }\r\n            } else if(countType === 'reweighted') {\r\n                var sumScoreForWinners = 0\r\n                vote.forEach(function(score, candidateIndex) {\r\n                    if(candidateIndex in winners) {\r\n                        sumScoreForWinners += score\r\n                    }\r\n                })\r\n\r\n                var weight = 1/(1+sumScoreForWinners/2)\r\n            }\r\n\r\n            vote.forEach(function(score, candidateIndex) {\r\n                if(!(candidateIndex in disqualified)) {\r\n                    var hasntChosenAWinner = !(candidateIndex in winners)\r\n                    if(countType === 'reweighted') {\r\n                        countedVotes[candidateIndex].totalScore += score*weight\r\n                        countedVotes[candidateIndex].totalNumber ++\r\n                    } else if(countType !== 'maxMinority' || hasntChosenAWinner) {  // only count votes for new potential winners\r\n                        countedVotes[candidateIndex].totalScore += score\r\n                        countedVotes[candidateIndex].totalNumber ++\r\n                    }\r\n                }\r\n            })\r\n        })\r\n        return countedVotes\r\n    }\r\n}\r\n\r\n// threshold - a number between 0 and 1 inclusive\r\nfunction fractionalRepresentativeRankedVote(threshold) {\r\n    return function(votes, candidates, maxWinners) {\r\n        var minimumWinningVotes = votes.length*threshold\r\n        var originalVotes = votes\r\n\r\n        var currentWinners = {}, countedVotes = candidates.map(function(){return 0})\r\n        votes.forEach(function(vote) {\r\n            var candidateIndex = vote[0]\r\n            countedVotes[candidateIndex] ++\r\n        })\r\n\r\n        // select initial winners\r\n        for(var candidateIndex in countedVotes) {\r\n            var votesForThisCandidate = countedVotes[candidateIndex]\r\n            if(votesForThisCandidate >= minimumWinningVotes) {\r\n                currentWinners[candidateIndex] = true\r\n            }\r\n        }\r\n\r\n        // remove votes of those who have chosen a winner\r\n        votes = votes.filter(function(vote) {\r\n            return !(vote[0] in currentWinners)\r\n        })\r\n\r\n        // iterate through preferences to find more winners\r\n        for(var currentPreferenceIndex = 1; currentPreferenceIndex<candidates.length; currentPreferenceIndex++) {\r\n            votes.forEach(function(vote) {\r\n                var candidateIndex = vote[currentPreferenceIndex]\r\n                countedVotes[candidateIndex] ++\r\n            })\r\n\r\n            // if there are any winners combining preferences 0 through n, choose best winner who isn't already a winner\r\n            var leadingNonWinner, leadingNonWinnerVotes = 0\r\n            for(var candidateIndex in countedVotes) {\r\n                var votesForThisCandidate = countedVotes[candidateIndex]\r\n                if(votesForThisCandidate >= minimumWinningVotes) {\r\n                    if(!(candidateIndex in currentWinners) && votesForThisCandidate > leadingNonWinnerVotes) {\r\n                        leadingNonWinner = candidateIndex\r\n                        leadingNonWinnerVotes = votesForThisCandidate\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(leadingNonWinner !== undefined) {\r\n                currentWinners[leadingNonWinner] = true\r\n            }\r\n\r\n            // redact votes by voters who have chosen a winner from non-winners they previously chose\r\n            votes.forEach(function(vote) {\r\n                var curCandidateIndex = vote[currentPreferenceIndex]\r\n                if(curCandidateIndex in currentWinners) {\r\n                    for(var n=0; n<currentPreferenceIndex; n++) {\r\n                        var candidatePreferenceIndex = vote[n]\r\n                        countedVotes[candidatePreferenceIndex] --\r\n                    }\r\n                }\r\n            })\r\n\r\n            // remove votes of those who have just chosen a winner\r\n            votes = votes.filter(function(vote) {\r\n                return !(vote[currentPreferenceIndex] in currentWinners)\r\n            })\r\n        }\r\n\r\n        // this needs to happen because its possible for a vote to be counted for an earlier winner,\r\n        // when the vote's preference is for a winner that was chosen in a later round\r\n        var winnersRecount = candidates.map(function(){return 0})\r\n        originalVotes.forEach(function(vote) {\r\n            for(var n=0;n<vote.length;n++) {\r\n                if(vote[n] in currentWinners) {\r\n                    winnersRecount[vote[n]] ++\r\n                    break;\r\n                }\r\n            }\r\n        })\r\n\r\n        var finalWinners = []\r\n        for(var candidateIndex in currentWinners) {\r\n            var votesForThisCandidate = winnersRecount[candidateIndex]\r\n            finalWinners.push({index: candidateIndex, weight:votesForThisCandidate/originalVotes.length})\r\n        }\r\n\r\n        return finalWinners.slice(0, maxWinners)\r\n    }\r\n}\r\n\r\nfunction singleTransferrableVote(votes, candidates, maxWinners) {\r\n    var seats = maxWinners\r\n    var voteQuota = 1+votes.length/(seats+1)\r\n\r\n    var newVotesMap = function() {\r\n        var votesList = {}\r\n        candidates.forEach(function(candidate, index){\r\n            votesList[index] = {currentVotes: [], currentCount:0}\r\n        })\r\n\r\n        return votesList\r\n    }\r\n\r\n    var countedVotes = newVotesMap(), currentWinners = {}, eliminatedCandidates = {}\r\n    votes.forEach(function(vote) {\r\n        var candidate = countedVotes[vote[0]]\r\n        candidate.currentVotes.push({vote:vote, weight:1, currentPreferenceIndex:0})\r\n        candidate.currentCount ++\r\n    })\r\n\r\n    var transferVotes = function(transferOrigin, transferDestination, ratioToTransfer) {\r\n        transferOrigin.currentVotes.forEach(function(voteInfo) {\r\n            var newCandidatePreference = voteInfo.currentPreferenceIndex +1\r\n            while(true) {\r\n                var nextCandidatePreference = voteInfo.vote[newCandidatePreference]\r\n                if(nextCandidatePreference in eliminatedCandidates || nextCandidatePreference in currentWinners) {\r\n                    newCandidatePreference ++\r\n                } else {\r\n                    break\r\n                }\r\n            }\r\n\r\n            var candidateIndex = voteInfo.vote[newCandidatePreference]\r\n            if(candidateIndex !== undefined) {\r\n                transferDestination[candidateIndex].currentVotes.push({        // transfer the excess\r\n                    vote:voteInfo.vote,\r\n                    weight:voteInfo.weight*ratioToTransfer,\r\n                    currentPreferenceIndex:newCandidatePreference\r\n                })\r\n                transferDestination[candidateIndex].currentCount += voteInfo.weight*ratioToTransfer\r\n            }\r\n\r\n            //transferOrigin.currentCount -= voteInfo.weight*ratioToTransfer // just for testing // todo: comment this out\r\n            voteInfo.weight *= (1-ratioToTransfer) // keep the remainder\r\n        })\r\n    }\r\n\r\n    while(true) {\r\n        var votesInTranfer = newVotesMap()\r\n        while(true) {\r\n            var excessFound = false\r\n            for(var candidateIndex in countedVotes) {\r\n                var votes = countedVotes[candidateIndex].currentCount\r\n                if(votes >= voteQuota - .01) {\r\n                    currentWinners[candidateIndex] = true\r\n                    if(votes > voteQuota) {\r\n                        excessFound = true\r\n                        var excessVotes = votes - voteQuota\r\n                        var excessRatio = excessVotes/votes\r\n\r\n                        transferVotes(countedVotes[candidateIndex], votesInTranfer, excessRatio)\r\n\r\n                        // When testing, ensure that countedVotes[candidateIndex].currentCount already is equal to voteQuota when testing line A is uncommented\r\n                        countedVotes[candidateIndex].currentCount = voteQuota\r\n                    }\r\n                }\r\n            }\r\n\r\n            if(!excessFound) {\r\n                break\r\n            } else {\r\n                for(var candidateIndex in votesInTranfer) {\r\n                    var newVotes = votesInTranfer[candidateIndex]\r\n                    newVotes.currentVotes.forEach(function(vote) {\r\n                        countedVotes[candidateIndex].currentVotes.push(vote)\r\n                    })\r\n\r\n                    if(newVotes.currentCount > 0)\r\n                        countedVotes[candidateIndex].currentCount += newVotes.currentCount\r\n                }\r\n\r\n                votesInTranfer = newVotesMap()\r\n            }\r\n        }\r\n\r\n        if(Object.keys(currentWinners).length < seats) {\r\n            // find candidate with least votes\r\n            var candidateWithLeastCount=undefined, lowestCount=undefined\r\n            for(var candidateIndex in countedVotes) {\r\n                var candidate = countedVotes[candidateIndex]\r\n                if(lowestCount === undefined || candidate.currentCount < lowestCount) {\r\n                    lowestCount = candidate.currentCount\r\n                    candidateWithLeastCount = candidateIndex\r\n                }\r\n            }\r\n\r\n            eliminatedCandidates[candidateWithLeastCount] = true\r\n\r\n            // transfer votes from that candidate\r\n            transferVotes(countedVotes[candidateWithLeastCount], countedVotes, 1)\r\n\r\n            if(Object.keys(countedVotes).length === 1) { // if there's only one candidate left, make them a winner even tho they didn't reach the quota\r\n                currentWinners[candidateWithLeastCount] = true\r\n                break\r\n            } else {\r\n                // eliminate the candidate\r\n                delete countedVotes[candidateWithLeastCount]\r\n            }\r\n        } else {\r\n            break\r\n        }\r\n    }\r\n\r\n    var finalWinners = []\r\n    for(var candidateIndex in currentWinners) {\r\n        finalWinners.push({index: candidateIndex, weight:1})\r\n    }\r\n\r\n    return finalWinners\r\n}\r\n\r\n\r\nmodule.exports = {\r\n    random: {\r\n        '':function(votes, candidates, maxWinners) {\r\n            if(candidates.length < maxWinners) maxWinners = candidates.length\r\n\r\n            var winners = []\r\n            for(var n=0; n<maxWinners;) {\r\n                var winner = Math.round(random()*(candidates.length-1))\r\n                if(winners.indexOf(winner) === -1) {\r\n                    winners.push(winner)\r\n                    n++\r\n                }\r\n            }\r\n\r\n            return winners.map(function(winner) {\r\n                return {index: winner, weight:1}\r\n            })\r\n        }\r\n    },\r\n    randomVotersChoice: {\r\n        'single voter':function(votes, candidates, maxWinners) {\r\n            var luckyWinnerIndex = Math.round(random()*(votes.length-1))\r\n            var luckyWinnerVote = votes[luckyWinnerIndex]\r\n\r\n            return luckyWinnerVote.slice(0,maxWinners).map(function(vote) {\r\n                return {index: vote, weight:1}\r\n            })\r\n        },\r\n        '10% of the voters': function(votes, candidates, maxWinners) {\r\n            var luckyVotes = []\r\n            while(luckyVotes.length < votes.length*.1) {\r\n                var luckyWinnerIndex = Math.round(random()*(votes.length-1))\r\n                luckyVotes.push(votes[luckyWinnerIndex][0])\r\n            }\r\n\r\n            return pluralityAlg(luckyVotes, candidates, maxWinners)\r\n        }\r\n    },\r\n    plurality: {\r\n        '':pluralityAlg\r\n    },\r\n    range: {\r\n        'One Winner': function(votes, candidates) {\r\n            var results = []\r\n            for(var n=0; n<candidates.length;n++) {\r\n                results[n] = 0\r\n            }\r\n\r\n            votes.forEach(function(vote){\r\n                vote.forEach(function(value, index) {\r\n                    results[index] += value\r\n                })\r\n            })\r\n\r\n            var transformedResults = results.map(function(value,index){\r\n                return {candidate:index,votes:value}\r\n            })\r\n\r\n            transformedResults.sort(function(a,b) {\r\n                return b.votes - a.votes // reverse sort\r\n            })\r\n\r\n            var winner = transformedResults[0].candidate\r\n            return [{index: winner, weight:1, preferences:candidates[winner]}]\r\n        },\r\n        'Three Winners': function(votes, candidates) {\r\n            var results = []\r\n            for(var n=0; n<candidates.length;n++) {\r\n                results[n] = 0\r\n            }\r\n\r\n            votes.forEach(function(vote){\r\n                vote.forEach(function(value, index) {\r\n                    results[index] += value\r\n                })\r\n            })\r\n\r\n            var transformedResults = results.map(function(value,index){\r\n                return {candidate:index,votes:value}\r\n            })\r\n\r\n            transformedResults.sort(function(a,b) {\r\n                return b.votes - a.votes // reverse sort (most votes foist)\r\n            })\r\n\r\n            var winners = [], totalScore = 0\r\n            for(var n=0; n<3; n++) {\r\n                var winnerIndex = transformedResults[n].candidate\r\n                var winner = candidates[winnerIndex]\r\n                winners.push({index: winnerIndex, preferences:winner})\r\n                totalScore+= transformedResults[n].votes\r\n            }\r\n\r\n            winners.forEach(function(winner, index) {\r\n                winner.weight = transformedResults[index].votes/totalScore\r\n            })\r\n\r\n            return winners\r\n        }\r\n    },\r\n    singleTransferableVote: {\r\n        '':singleTransferrableVote\r\n    },\r\n    directRepresentativeRanked: {\r\n        '15% Threshold': {'':fractionalRepresentativeRankedVote(.15)},\r\n    },\r\n    directRepresentativeRanged: {\r\n        'split-weight, 0% threshold': directRepresentationRange('normal', 'split',0),\r\n        'highest-weight, 20% threshold': directRepresentationRange('normal', 'highest', .5),\r\n        'split-weight, 20% threshold': directRepresentationRange('normal', 'split', .9),\r\n        'equal-weight, 20% threshold': directRepresentationRange('normal', 'equal', .9),\r\n        'highest-weight, minority-max, 20% threshold': directRepresentationRange('maxMinority', 'highest', .9),\r\n        'split-weight, minority-max, 20% threshold': directRepresentationRange('maxMinority', 'split', .9),\r\n        'equal-weight, minority-max, 20% threshold': directRepresentationRange('maxMinority', 'equal', .9),\r\n        'highest-weight, <b>reweighted</b>': directRepresentationRange('reweighted', 'highest', 0),\r\n        'split-weight, <b>reweighted</b>': directRepresentationRange('reweighted', 'split', 0),\r\n        'equal-weight, <b>reweighted</b>': directRepresentationRange('reweighted', 'equal', 0),\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./votingSystems.js\n ** module id = 2\n ** module chunks = 0\n **/","\r\nvar utils = require('./utils')\r\n\r\n// votes are floating point numbers between 0 and 1\r\nfunction rangeStrategy_honestExact(voter, aggregates) {\r\n    // the maximum utility that the best dictator-candidate would give for this voter\r\n    var maxUtility = Math.max.apply(null, aggregates.candidateDictatorUtilities)\r\n    var minUtility = Math.min.apply(null, aggregates.candidateDictatorUtilities)\r\n\r\n    return aggregates.candidateDictatorUtilities.map(function(utility) {\r\n        if(maxUtility === minUtility) { // this branch prevents a divide by 0 error\r\n            return .5\r\n        } else {\r\n            var utilityFraction = (utility-minUtility)/(maxUtility-minUtility)\r\n            return utilityFraction\r\n        }\r\n    })\r\n}\r\n\r\nfunction rankedVote_honest(voter, aggregates) {\r\n    var order = aggregates.candidateDictatorUtilities.map(function(candidateUtility, index) {\r\n        return {utility: candidateUtility, index:index}\r\n    }).sort(function(a,b) {\r\n        return b.utility-a.utility // highest to lowest\r\n    })\r\n\r\n    return order.map(function(x) {\r\n        return x.index\r\n    })\r\n}\r\n\r\n\r\nmodule.exports = {\r\n    ranked: {\r\n        Honest: rankedVote_honest\r\n    },\r\n    scored: {\r\n        Honest: rangeStrategy_honestExact\r\n    },\r\n    noop: {\r\n        '':function(){}\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./votingStrategies.js\n ** module id = 3\n ** module chunks = 0\n **/","var noop = function(vote){return vote}\r\n\r\nmodule.exports = {\r\n    noop: {'':noop},\r\n    ranked: {\r\n        \"raw\":noop,\r\n        \"Max 3\": function(vote) {\r\n            return vote.slice(0,3)\r\n        }\r\n    },\r\n    scored: {\r\n        \"raw\":noop,\r\n        \"Nearest 1-5\": function(vote) {\r\n            return vote.map(function(candidateScore) {\r\n                return Math.round(5*candidateScore)/5\r\n            })\r\n        }\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./ballots.js\n ** module id = 4\n ** module chunks = 0\n **/","\r\n\r\n// random number between 0 and 1 (just like Math.random)\r\nexports.random = function() {\r\n    var randomInteger = getRandomInt(0,255)\r\n    return randomInteger/255\r\n}\r\n\r\nfunction getRandomInt(min, max) {\r\n    // Create byte array and fill with 1 random number\r\n    var byteArray = new Uint8Array(1);\r\n    window.crypto.getRandomValues(byteArray);\r\n\r\n    var range = max - min + 1;\r\n    var max_range = 256;\r\n    if (byteArray[0] >= Math.floor(max_range / range) * range)\r\n        return getRandomInt(min, max);\r\n    return min + (byteArray[0] % range);\r\n}\r\n\r\n// Returns the results of a yes/no weighted majority vote on each societal preference as an array where\r\n// each index indicates the societal option and the value is either true or false\r\n// deciders - An array of winning candidates in the same form as this.elect returns\r\nmodule.exports.findSocietalOptionsOutcomes = function(deciders) {\r\n    var voteWeightTotal = 0\r\n    var societalOptionsVotes = []\r\n    deciders.forEach(function(person) {\r\n        voteWeightTotal += person.weight\r\n        person.preferences.forEach(function(preference, index) {\r\n            if(societalOptionsVotes[index] === undefined) {\r\n                societalOptionsVotes[index] = 0\r\n            }\r\n\r\n            if(preference > 0) {\r\n                societalOptionsVotes[index] += person.weight\r\n            }\r\n        })\r\n    })\r\n\r\n    return societalOptionsVotes.map(function(votesForOneSocietalOption) {\r\n        return votesForOneSocietalOption/voteWeightTotal > .5\r\n    })\r\n}\r\n\r\nmodule.exports.voterOutcomeUtility = function(voter, outcomes) {\r\n    var totalUtility =  0\r\n    voter.forEach(function(utility,index) {\r\n        if(outcomes[index])\r\n            totalUtility += utility\r\n    })\r\n\r\n    return totalUtility\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./utils.js\n ** module id = 5\n ** module chunks = 0\n **/","\r\nvar utils = require('./utils')\r\n\r\nmodule.exports = {\r\n    candidateDictatorUtilities: function(voters, candidates) {\r\n        var candidateOutcomes = candidates.map(function(candidate) {\r\n            return  utils.findSocietalOptionsOutcomes([{weight:1, preferences:candidate}])\r\n        })\r\n        // the utility each voter would get if each candidate were elected dictator\r\n        return voters.map(function(voter) {\r\n            return candidateOutcomes.map(function(outcomes) {\r\n                return  utils.voterOutcomeUtility(voter, outcomes)\r\n            })\r\n        })\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./aggregateFns.js\n ** module id = 6\n ** module chunks = 0\n **/","\"use strict\";\r\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar noop = function() {}\r\n\r\nvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\nfunction proto() {\r\n    var args = arguments // minifiable variables\r\n\r\n    if(args.length == 1) {\r\n        var parent = {init: noop}\r\n        var prototypeBuilder = args[0]\r\n\r\n    } else { // length == 2\r\n        var parent = args[0]\r\n        var prototypeBuilder = args[1]\r\n    }\r\n\r\n    // special handling for Error objects\r\n    var namePointer = {}    // name used only for Error Objects\r\n    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n        parent = normalizeErrorObject(parent, namePointer)\r\n    }\r\n\r\n    // set up the parent into the prototype chain if a parent is passed\r\n    var parentIsFunction = typeof(parent) === \"function\"\r\n    if(parentIsFunction) {\r\n        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n    } else {\r\n        prototypeBuilder[prototypeName] = parent\r\n    }\r\n\r\n    // the prototype that will be used to make instances\r\n    var prototype = new prototypeBuilder(parent)\r\n    namePointer.name = prototype.name\r\n\r\n    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n    if(!prototype[init] && parentIsFunction) {\r\n        prototype[init] = function() {\r\n            parent.apply(this, arguments)\r\n        }\r\n    }\r\n\r\n    // constructor for empty object which will be populated via the constructor\r\n    var F = function() {}\r\n        F[prototypeName] = prototype    // set the prototype for created instances\r\n\r\n    var constructorName = prototype.name?prototype.name:''\r\n    if(prototype[init] === undefined || prototype[init] === noop) {\r\n        var ProtoObjectFactory = new Function('F',\r\n            \"return function \" + constructorName + \"(){\" +\r\n                \"return new F()\" +\r\n            \"}\"\r\n        )(F)\r\n    } else {\r\n        // dynamically creating this function cause there's no other way to dynamically name a function\r\n        var ProtoObjectFactory = new Function('F','i','u','n', // shitty variables cause minifiers aren't gonna minify my function string here\r\n            \"return function \" + constructorName + \"(){ \" +\r\n                \"var x=new F(),r=i.apply(x,arguments)\\n\" +    // populate object via the constructor\r\n                \"if(r===n)\\n\" +\r\n                    \"return x\\n\" +\r\n                \"else if(r===u)\\n\" +\r\n                    \"return n\\n\" +\r\n                \"else\\n\" +\r\n                    \"return r\\n\" +\r\n            \"}\"\r\n        )(F, prototype[init], proto[protoUndefined]) // note that n is undefined\r\n    }\r\n\r\n    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n\r\n    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n    for(var n in prototype) {\r\n        addProperty(ProtoObjectFactory, prototype, n)\r\n    }\r\n\r\n    // add properties from parent that don't exist in the static class object yet\r\n    for(var n in parent) {\r\n        if(ownProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n            addProperty(ProtoObjectFactory, parent, n)\r\n        }\r\n    }\r\n\r\n    ProtoObjectFactory.parent = parent;            // special parent property only available on the returned proto class\r\n    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\r\n    return ProtoObjectFactory;\r\n}\r\n\r\nproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\r\nmodule.exports = proto\r\n\r\nfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n    function NormalizedError() {\r\n        var tmp = new ErrorObject(arguments[0])\r\n        tmp.name = namePointer.name\r\n\r\n        this.message = tmp.message\r\n        if(Object.defineProperty) {\r\n            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n                get: function() {\r\n                    return tmp.stack\r\n                },\r\n                configurable: true // so you can change it if you want\r\n            })\r\n        } else {\r\n            this.stack = tmp.stack\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    var IntermediateInheritor = function() {}\r\n        IntermediateInheritor.prototype = ErrorObject.prototype\r\n    NormalizedError.prototype = new IntermediateInheritor()\r\n\r\n    return NormalizedError\r\n}\r\n\r\nfunction addProperty(factoryObject, prototype, property) {\r\n    try {\r\n        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n            Object.defineProperty(factoryObject, property, info)\r\n        } else {\r\n            factoryObject[property] = prototype[property]\r\n        }\r\n    } catch(e) {\r\n        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/proto/proto.js\n ** module id = 7\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"elect.umd.js"}